//this is my orderModel.js page:- 
    paymentStatus: {
        type: String,
        enum:['Paid','Pending','Failed'],
        required: true

//this is my orderController.js page :- 
const {addToWallet}=require("../../controllers/user/walletController")

const Razorpay = require('razorpay');
const crypto = require('crypto');


const razorpay = new Razorpay({
    key_id: process.env.RAZORPAY_KEY_ID,
    key_secret: process.env.RAZORPAY_KEY_SECRET
});


const createOrder = async (req, res) => {
    try {
        const userId = req.session.user;
        const { paymentMethod, addressId } = req.body;

        if (!userId) {
            return res.status(401).json({ success: false, message: "Please login to place an order." });
        }

        const cart = await Cart.findOne({ userId }).populate({
            path: 'items.product',
            populate: {
                path: 'category',
                model: 'Category'
            }
        });

        if (!cart || cart.items.length === 0) {
            return res.status(400).json({ success: false, message: "Your cart is empty." });
        }

        // Check stock availability
        for (const item of cart.items) {
            const product = await Product.findById(item.product._id);
            if (product.quantity < item.quantity) {
                return res.status(400).json({ 
                    success: false, 
                    message: `Insufficient stock for ${product.productName}. Only ${product.quantity} available.` 
                });
            }
        }

        const address = await Address.findOne({ userId });
        if (!address || !address.address[addressId]) {
            return res.status(404).json({ success: false, message: "Address not found." });
        }

        const selectedAddress = address.address[addressId];

        // Calculate prices with offers
        const orderItems = [];
        let subtotal = 0;
        
        for (const item of cart.items) {
            const product = await Product.findById(item.product._id);
            const originalPrice = product.regularPrice;
            
            // Get active offers
            const currentDate = new Date();
            const offers = await Offer.find({
                status: 'Active',
                expireDate: { $gt: currentDate }
            });
            
            const productOffer = offers.find(offer => 
                (offer.productIds?.includes(product._id)) ||
                (offer.categoryIds?.includes(product.category))
            );

            const priceAfterOffer = productOffer 
                ? originalPrice * (1 - productOffer.discount / 100)
                : originalPrice;
            
            const itemSubtotal = priceAfterOffer * item.quantity;
            subtotal += itemSubtotal;

            orderItems.push({
                productId: product._id,
                productName: product.productName,
                quantity: item.quantity,
                price: originalPrice,
                finalPrice: itemSubtotal,
                itemStatus: "Ordered",
                highestDiscount: productOffer ? productOffer.discount : 0
            });
        }

        // Apply coupon if exists
        let finalAmount = subtotal;
        const appliedCoupon = req.session.appliedCoupon;
        
        if (appliedCoupon) {
            const discountAmount = appliedCoupon.discountAmount;
            finalAmount = subtotal - discountAmount;

            orderItems.forEach(item => {
                const proportion = item.finalPrice / subtotal;
                const itemDiscount = discountAmount * proportion;
                item.finalPrice -= itemDiscount;
            });
        }

        // Process based on payment method
        switch (paymentMethod) {
            case 'COD': {
                const newOrder = new Order({
                    orderId: `ORD-${Date.now()}`,
                    userId,
                    items: orderItems,
                    totalPrice: finalAmount,
                    address: {
                        name: selectedAddress.name,
                        phone: selectedAddress.phone,
                        district: selectedAddress.district,
                        city: selectedAddress.city,
                        house: selectedAddress.house,
                        state: selectedAddress.state,
                        pincode: selectedAddress.pincode,
                    },
                    paymentMethod,
                    paymentStatus: 'Pending',
                    orderStatus: "Processing"
                });

                await newOrder.save();

                // Update product quantities
                for (const item of orderItems) {
                    await Product.findByIdAndUpdate(
                        item.productId,
                        { $inc: { quantity: -item.quantity } }
                    );
                }

                // Clear cart and coupon
                await Cart.deleteOne({ userId });
                delete req.session.appliedCoupon;

                return res.status(200).json({ 
                    success: true, 
                    orderId: newOrder.orderId 
                });
            }

            case 'Wallet': {
                const wallet = await Wallet.findOne({ userId });
                
                if (!wallet || wallet.balance < finalAmount) {
                    return res.status(400).json({ 
                        success: false, 
                        message: 'Insufficient wallet balance' 
                    });
                }

                const newOrder = new Order({
                    orderId: `ORD-${Date.now()}`,
                    userId,
                    items: orderItems,
                    totalPrice: finalAmount,
                    address: {
                        name: selectedAddress.name,
                        phone: selectedAddress.phone,
                        district: selectedAddress.district,
                        city: selectedAddress.city,
                        house: selectedAddress.house,
                        state: selectedAddress.state,
                        pincode: selectedAddress.pincode,
                    },
                    paymentMethod,
                    paymentStatus: 'Paid',
                    orderStatus: "Processing"
                });

                await newOrder.save();

                // Update product quantities
                for (const item of orderItems) {
                    await Product.findByIdAndUpdate(
                        item.productId,
                        { $inc: { quantity: -item.quantity } }
                    );
                }

                // Update wallet
                wallet.balance -= finalAmount;
                wallet.transactions.push({
                    amount: finalAmount,
                    type: 'debit',
                    description: `Payment for order ${newOrder.orderId}`,
                    balance: wallet.balance
                });
                await wallet.save();

                // Clear cart and coupon
                await Cart.deleteOne({ userId });
                delete req.session.appliedCoupon;

                return res.status(200).json({ 
                    success: true, 
                    orderId: newOrder.orderId 
                });
            }

            case 'Razorpay': {
                const razorpayOrderOptions = {
                    amount: Math.round(finalAmount * 100),
                    currency: 'INR',
                    receipt: `ORD-${Date.now()}`,
                    payment_capture: 1
                };

                const razorpayOrder = await razorpay.orders.create(razorpayOrderOptions);

                const newOrder = new Order({
                    orderId: `ORD-${Date.now()}`,
                    userId,
                    items: orderItems,
                    totalPrice: finalAmount,
                    address: {
                        name: selectedAddress.name,
                        phone: selectedAddress.phone,
                        district: selectedAddress.district,
                        city: selectedAddress.city,
                        house: selectedAddress.house,
                        state: selectedAddress.state,
                        pincode: selectedAddress.pincode,
                    },
                    paymentMethod,
                    paymentStatus: 'Pending',
                    orderStatus: "Processing",
                    razorpayOrderId: razorpayOrder.id
                });

                await newOrder.save();

                // Update product quantities
                for (const item of orderItems) {
                    await Product.findByIdAndUpdate(
                        item.productId,
                        { $inc: { quantity: -item.quantity } }
                    );
                }

                // Clear cart and coupon
                await Cart.deleteOne({ userId });
                delete req.session.appliedCoupon;

                return res.status(200).json({ 
                    success: true, 
                    orderId: newOrder.orderId,
                    razorpayOrder: {
                        id: razorpayOrder.id,
                        key: process.env.RAZORPAY_KEY_ID,
                        amount: razorpayOrder.amount
                    }
                });
            }

            default:
                return res.status(400).json({ 
                    success: false, 
                    message: 'Invalid payment method' 
                });
        }

    } catch (error) {
        console.error("Error placing order:", error);
        return res.status(500).json({ 
            success: false, 
            message: error.message || 'An error occurred while placing the order' 
        });
    }
};

//razorpay
const verifyRazorpayPayment = async (req, res) => {
    try {
        const { razorpay_order_id, razorpay_payment_id, razorpay_signature } = req.body;

        // First verify the payment signature
        const hmac = crypto.createHmac('sha256', process.env.RAZORPAY_KEY_SECRET);
        hmac.update(`${razorpay_order_id}|${razorpay_payment_id}`);
        const generatedSignature = hmac.digest('hex');

        if (generatedSignature !== razorpay_signature) {
            return res.status(400).json({ success: false, message: 'Invalid payment signature' });
        }

        // Find the order
        const order = await Order.findOne({ razorpayOrderId: razorpay_order_id });
        
        if (!order) {
            console.error('Order not found for Razorpay order ID:', razorpay_order_id);
            return res.status(404).json({ success: false, message: 'Order not found' });
        }

        // Update the order with payment details
        order.paymentStatus = 'Paid';
        order.paymentMethod = 'Razorpay';
        order.razorpayPaymentId = razorpay_payment_id;
        
        await order.save();

        return res.status(200).json({ 
            success: true, 
            message: 'Payment verified successfully',
            orderId: order.orderId
        });

    } catch (error) {
        console.error('Razorpay verification error:', error);
        res.status(500).json({ success: false, message: 'Payment verification failed' });
    }
};

//ordersuccess
const orderSuccess = async (req,res)=>{
  try {

    const userData = req.session.user ? await User.findById(req.session.user) : null;
    
    const { orderId } = req.params;
    
    const order = await Order.findOne({ orderId });

    if (!order) {
      return res.status(404).json({ success: false, message: 'Order not found' });
    }

    await order.save();

    const user = await User.findById(order.userId);

    if (!user.orderHistory) {
      user.orderHistory = [];
    }

    user.orderHistory.push(order._id);
    await user.save();


    res.render('orderPlaced', {
      userData,
      order,
      user,
    });

  } catch (error) {
    console.error('Error in orderSuccess:', error);
    res.status(500).json({ success: false, message: 'An error occurred while processing the order' });
    
  }
}


//get view order page 
const getViewOrders = async (req, res) => {
    try {
        const userData = await User.findById(req.session.user);
        if (!userData) {
            return res.redirect('/login');
        }
    
        // Pagination setup
        const page = parseInt(req.query.page) || 1;
        const limit = 5;
        const skip = (page - 1) * limit;

        // Get total count first
        const totalOrdersCount = await Order.countDocuments({ userId: userData._id });
        const totalPages = Math.ceil(totalOrdersCount / limit);

        // Get paginated orders
        const orders = await Order.find({ userId: userData._id })
            .populate({
                path: 'items.productId',
                populate: {
                    path: 'category',
                    model: 'Category'
                }
            })
            .sort({ createdAt: -1 })
            .skip(skip)
            .limit(limit)
            .lean();

        // If no orders found, render the page with empty array
        if (!orders || orders.length === 0) {
            return res.render("viewOrders", {
                userData,
                orders: [],
                paginatedOrders: [],
                currentPage: 1,
                totalPages: 1,
                helpers: {
                    getStatusClass: (status) => {
                        switch (status.toLowerCase()) {
                            case 'paid': return 'paid';
                            case 'pending': return 'pending';
                            case 'processing': return 'processing';
                            case 'shipped': return 'shipped';
                            case 'delivered': return 'delivered';
                            default: return '';
                        }
                    }
                }
            });
        }

        // Format orders
        const formattedOrders = orders.map(order => {
            let subtotal = 0;
            let activeItemsCount = 0;
            
            const itemsWithOffers = order.items.map(item => {
                if (item.itemStatus !== 'Cancelled') {
                    activeItemsCount++;
                    subtotal += item.finalPrice;
                }
                
                return {
                    ...item,
                    originalPrice: item.price,
                    finalPrice: item.finalPrice
                };
            });

            // Recalculate coupon discount if applicable
            let finalTotal = subtotal;
            if (order.appliedCoupon && activeItemsCount > 0) {
                const couponDiscount = (subtotal / order.totalPrice) * order.appliedCoupon.discountAmount;
                finalTotal = subtotal - couponDiscount;
            }

            return {
                orderId: order.orderId,
                date: new Date(order.createdAt).toLocaleDateString('en-US', {
                    year: 'numeric',
                    month: '2-digit',
                    day: '2-digit'
                }),
                totalPrice: finalTotal.toFixed(2),
                originalTotal: order.totalPrice,
                paymentStatus: order.paymentStatus,
                orderStatus: order.orderStatus,
                items: itemsWithOffers,
                appliedCoupon: order.appliedCoupon
            };
        });

        res.render("viewOrders", {
            userData,
            orders: formattedOrders,
            paginatedOrders: formattedOrders,
            currentPage: page,
            totalPages,
            helpers: {
                getStatusClass: (status) => {
                    switch (status.toLowerCase()) {
                        case 'paid': return 'paid';
                        case 'pending': return 'pending';
                        case 'processing': return 'processing';
                        case 'shipped': return 'shipped';
                        case 'delivered': return 'delivered';
                        default: return '';
                    }
                }
            }
        });

    } catch (error) {
        console.error('Error in getViewOrders:', error);
        // Render a generic error page instead of looking for specific error view
        res.render("viewOrders", {
            userData: req.session.user ? await User.findById(req.session.user) : null,
            orders: [],
            paginatedOrders: [],
            currentPage: 1,
            totalPages: 1,
            error: "An error occurred while fetching your orders. Please try again later.",
            helpers: {
                getStatusClass: (status) => {
                    switch (status.toLowerCase()) {
                        case 'paid': return 'paid';
                        case 'pending': return 'pending';
                        case 'processing': return 'processing';
                        case 'shipped': return 'shipped';
                        case 'delivered': return 'delivered';
                        default: return '';
                    }
                }
            }
        });
    }
};

//get order details
const getOrderDetails = async (req, res) => {
    try {
        const userData = await User.findById(req.session.user);
        const { orderId } = req.params;

        const order = await Order.findOne({ orderId }).populate({
            path: 'items.productId',
            model: 'Product',
            populate: {
                path: 'category',
                model: 'Category',
                select: 'name'
            }
        });

        if (!order) {
            return res.status(404).render('error', {
                message: 'Order not found',
                error: { status: 404 }
            });
        }

        // Calculate active items and their totals
        let activeSubtotal = 0;
        let activeItemsCount = 0;

        const processedItems = order.items.map(item => {
            const itemData = {
                productName: item.productName,
                productId: item.productId,
                quantity: item.quantity,
                price: item.price,
                highestDiscount: item.highestDiscount || 0,
                offerPrice: item.highestDiscount > 0 ? 
                    item.price * (1 - item.highestDiscount / 100) : 
                    item.price,
                finalPrice: item.finalPrice,
                itemStatus: item.itemStatus,
                returnStatus: item.returnStatus || 'Not Requested',
                returnReason: item.returnReason || '',
                category: item.productId.category
            };

            if (item.itemStatus !== 'Cancelled') {
                activeSubtotal += item.finalPrice;
                activeItemsCount++;
            }

            return itemData;
        });

        // Calculate coupon distribution for active items
        let finalTotal = activeSubtotal;
        if (order.appliedCoupon && activeItemsCount > 0) {
            const proportionalDiscount = (activeSubtotal / order.totalPrice) * order.appliedCoupon.discountAmount;
            finalTotal = activeSubtotal - proportionalDiscount;
        }

        const formattedOrder = {
            orderId: order.orderId,
            orderDate: new Date(order.createdAt).toLocaleDateString('en-US', {
                weekday: 'long',
                year: 'numeric',
                month: 'long',
                day: 'numeric'
            }),
            address: order.address,
            paymentMethod: order.paymentMethod,
            paymentStatus: order.paymentStatus,
            orderStatus: order.orderStatus,
            items: processedItems.map(item => ({
                productName: item.productName,
                category: item.category,
                image: item.productId.productImage[0],
                quantity: item.quantity,
                price: item.price,
                offerPrice: item.offerPrice,
                highestDiscount: item.highestDiscount,
                finalPrice: item.finalPrice,
                itemStatus: item.itemStatus,
                returnStatus: item.returnStatus
            })),
            totalPrice: order.totalPrice,
            appliedCoupon: order.appliedCoupon ? {
                code: order.appliedCoupon.code,
                discountAmount: order.appliedCoupon.discountAmount
            } : null
        };

        res.render("orderDetails", {
            userData,
            order: formattedOrder
        });

    } catch (error) {
        console.error('Error in getOrderDetails:', error);
        res.status(500).render('error', {
            message: 'An error occurred while fetching order details',
            error: process.env.NODE_ENV === 'development' ? error : {}
        });
    }
};


//cancelled order
const cancelOrderItem = async (req, res) => {
    try {
        const { orderId } = req.params;
        const { productName, reason } = req.body;
        
        const order = await Order.findOne({ orderId });
        if (!order) {
            return res.status(404).json({ success: false, message: 'Order not found' });
        }

        const itemIndex = order.items.findIndex(item => item.productName === productName);
        if (itemIndex === -1) {
            return res.status(404).json({ success: false, message: 'Product not found in order' });
        }

        const item = order.items[itemIndex];
        if (item.itemStatus !== 'Ordered' && item.itemStatus !== 'Processing') {
            return res.status(400).json({ 
                success: false, 
                message: 'This item cannot be cancelled in its current status' 
            });
        }

        // Calculate refund amount including proportional coupon discount
        let refundAmount = item.finalPrice;
        if (order.appliedCoupon) {
            const proportionalDiscount = (item.finalPrice / order.totalPrice) * order.appliedCoupon.discountAmount;
            refundAmount = item.finalPrice - proportionalDiscount;
        }

        // Process refund to wallet for paid orders
        if ((order.paymentMethod === 'Razorpay' || order.paymentMethod === 'Wallet') && 
            order.paymentStatus === 'Paid') {
            let wallet = await Wallet.findOne({ userId: order.userId });
            
            if (!wallet) {
                wallet = new Wallet({
                    userId: order.userId,
                    balance: 0,
                    transactions: []
                });
            }

            // Add refund transaction
            const newBalance = wallet.balance + refundAmount;
            wallet.transactions.push({
                amount: refundAmount,
                type: 'credit',
                description: `Refund for cancelled item: ${item.productName}`,
                orderId: order._id,
                balance: newBalance
            });

            wallet.balance = newBalance;
            await wallet.save();
        }

        // Update item status and product inventory
        item.itemStatus = 'Cancelled';
        item.reason = reason;

        const product = await Product.findById(item.productId);
        if (product) {
            product.quantity += item.quantity;
            await product.save();
        }

        // Recalculate order total
        const activeItems = order.items.filter(item => item.itemStatus !== 'Cancelled');
        order.totalPrice = activeItems.reduce((total, item) => total + item.finalPrice, 0);

        if (activeItems.length === 0) {
            order.orderStatus = 'Cancelled';
        }

        await order.save();

        res.status(200).json({
            success: true,
            message: 'Order item cancelled successfully. Refund has been processed to your wallet.',
            updatedTotalPrice: order.totalPrice,
            refundAmount: refundAmount
        });

    } catch (error) {
        console.error('Error in cancelOrderItem:', error);
        res.status(500).json({
            success: false,
            message: 'An error occurred while cancelling the order item'
        });
    }
};


//return order
const returnOrderItem = async (req, res) => {
    try {
        const { orderId } = req.params;
        const { productName, reason } = req.body;

        const order = await Order.findOne({ orderId });
        if (!order) {
            return res.status(404).json({ success: false, message: 'Order not found' });
        }

        const itemToReturn = order.items.find(item => 
            item.productName === productName && item.itemStatus === 'Delivered'
        );

        if (!itemToReturn) {
            return res.status(400).json({
                success: false,
                message: 'Item cannot be returned'
            });
        }

        // Calculate refund amount including proportional coupon discount
        let refundAmount = itemToReturn.finalPrice;
        if (order.appliedCoupon) {
            const proportionalDiscount = (itemToReturn.finalPrice / order.totalPrice) * order.appliedCoupon.discountAmount;
            refundAmount = itemToReturn.finalPrice - proportionalDiscount;
        }

        // Process refund to wallet
        if ((order.paymentMethod === 'Razorpay' || order.paymentMethod === 'Wallet') && 
            order.paymentStatus === 'Paid') {
            let wallet = await Wallet.findOne({ userId: order.userId });
            
            if (!wallet) {
                wallet = new Wallet({
                    userId: order.userId,
                    balance: 0,
                    transactions: []
                });
            }

            // Add refund transaction
            const newBalance = wallet.balance + refundAmount;
            wallet.transactions.push({
                amount: refundAmount,
                type: 'credit',
                description: `Refund for returned item: ${itemToReturn.productName}`,
                orderId: order._id,
                balance: newBalance
            });

            wallet.balance = newBalance;
            await wallet.save();
        }

        itemToReturn.returnReason = reason;
        itemToReturn.returnStatus = 'Return Requested';
        itemToReturn.returnRequestDate = new Date();
        itemToReturn.itemStatus = 'Return Processed';
        itemToReturn.refundAmount = refundAmount;

        await order.save();

        // Update product inventory
        const product = await Product.findById(itemToReturn.productId);
        if (product) {
            product.quantity += itemToReturn.quantity;
            await product.save();
        }

        res.json({
            success: true,
            message: 'Return request processed successfully. Refund has been added to your wallet.',
            returnStatus: 'Return Processed',
            refundAmount: refundAmount.toFixed(2)
        });

    } catch (error) {
        console.error('Error in returnOrderItem:', error);
        res.status(500).json({
            success: false,
            message: 'An error occurred while processing the return request'
        });
    }
};

//this is my checkout.ejs page:- 

                    <aside  class="sidebar">
                        <div class="summary">
                            <h3 class="summary-title">Order Summary</h3>
                            <table class="table table-summary">
                                <thead>
                                    <tr>
                                        <th>Product</th>
                                        <th>Total</th>
                                    </tr>
                                </thead>
                                <tbody>
                                    <% let calculatedSubtotal = 0 %>
                                    <% cart.items.forEach(item => { %>
                                        <% const product = item.product %>
                                        <% const originalPrice = Math.round((product.highestDiscount > 0 ? product.offerPrice : product.regularPrice) * 100) / 100 %>
                                        <% const itemTotal = Math.round(originalPrice * item.quantity * 100) / 100 %>
                                        <% const finalItemPrice = item.couponDiscount ? Math.round(item.couponDiscount.finalPrice) : itemTotal %>
                                        <% calculatedSubtotal += finalItemPrice %>
                                        <tr>
                                            <td>
                                                <%= product.productName %>
                                                <small class="d-block text-muted">
                                                    <% if (item.couponDiscount) { %>
                                                        <div class="price-details">
                                                            <span class="original-price" style="text-decoration: line-through; color: #999;">
                                                                ₹<%= itemTotal %>
                                                            </span>
                                                            <span class="arrow" style="color: #666; margin: 0 5px;">→</span>
                                                            <span class="discounted-price" style="color: #28a745;">
                                                                ₹<%= Math.round(item.couponDiscount.finalPrice) %>
                                                            </span>
                                                            <div class="discount-info" style="font-size: 0.85em; color: #28a745;">
                                                                You Saved: ₹<%= Math.round(item.couponDiscount.amount) %>
                                                            </div>
                                                        </div>
                                                    <% } %>
                                                </small>
                                            </td>
                                            <td class="text-right">₹<%= finalItemPrice %></td>
                                        </tr>
                                    <% }) %>
                                    
                                    <tr class="summary-subtotal">
                                        <td>Subtotal:</td>
                                        <td>₹<%= Math.round(calculatedSubtotal) %></td>
                                    </tr>
                                    
                                    <% if (appliedCoupon) { %>
                                        <tr style="color: #28a745;">
                                            <td>
                                                Coupon Applied (<%= appliedCoupon.code %>):
                                                <small class="d-block">
                                                    <%= appliedCoupon.percentage %>% off
                                                    <% if (appliedCoupon.appliedDiscount === 'Maximum discount applied') { %>
                                                        (Max: ₹<%= Math.round(appliedCoupon.maxRedeemAmount) %>)
                                                    <% } %>
                                                </small>
                                            </td>
                                            <td class="text-right">-₹<%= Math.round(appliedCoupon.discountAmount) %></td>
                                        </tr>
                                    <% } %>
                                    
                                    <tr class="total-row">
                                        <td><strong>Total:</strong></td>
                                        <td><strong>₹<%= Math.round(finalAmount) %></strong></td>
                                    </tr>
                                </tbody>
                            </table>

                            <div class="payment-method">
                                <h4 class="payment-method-title">Payment Method</h4>
                                
                                <div class="wallet-info mb-3">
                                    <p class="font-medium">Wallet Balance: ₹<span id="walletBalance"><%= walletBalance.toFixed(2) %></span></p>
                                </div>
                                
                                <div class="payment-option">
                                    <input type="radio" name="paymentMethod" value="COD" id="paymentCOD">
                                    <label for="paymentCOD">Cash on Delivery</label>
                                </div><br>
                                
                                <div class="payment-option">
                                    <input type="radio" name="paymentMethod" value="Razorpay" id="paymentRazorpay">
                                    <label for="paymentRazorpay">Razorpay</label>
                                </div><br>
                                
                                <div class="payment-option">
                                    <input type="radio" name="paymentMethod" value="Wallet" id="paymentWallet" 
                                        <%= (walletBalance < finalAmount) ? 'disabled' : '' %>>
                                    <label for="paymentWallet" class="<%= (walletBalance < finalAmount) ? 'text-muted' : '' %>">
                                        Wallet Payment 
                                        <% if (walletBalance < finalAmount) { %>
                                            <small class="text-danger">(Insufficient Balance)</small>
                                        <% } %>
                                    </label>
                                </div>
                            </div>
                            
                            <button type="button" id="placeOrderButton" class="btn btn-outline-primary-2 btn-block">Place Order</button>
                        </div>
                    </aside>
                </div>
            </div>
        </div>
    </div>
</main>

<script src="https://cdn.jsdelivr.net/npm/sweetalert2@11"></script>
<script>
    
    document.getElementById('show-addresses-btn').addEventListener('click', function() {
        const addressList = document.getElementById('address-list');
        addressList.style.display = addressList.style.display === 'none' ? 'block' : 'none';
    });

    
    function selectAddress(index) {
        document.querySelectorAll('.address-item').forEach(item => {
            item.classList.remove('selected');
            const icon = item.querySelector('.select-icon');
            if (icon) icon.classList.remove('selected');
        });

        const selectedItem = document.querySelector(`.address-item[data-index="${index}"]`);
        selectedItem.classList.add('selected');

        const selectIcon = document.getElementById(`select-icon-${index}`);
        selectIcon.classList.add('selected');

        sessionStorage.setItem('selectedAddress', index);
    }

    function toggleForm() {
    var form = document.getElementById("addAddressForm");
    form.style.display = form.style.display === "none" ? "block" : "none";
}

function cancelForm() {
    Swal.fire({
        title: 'Are you sure?',
        text: "Your entered data will be discarded!",
        icon: 'warning',
        showCancelButton: true,
        confirmButtonColor: '#3085d6',
        cancelButtonColor: '#d33',
        confirmButtonText: 'Yes, cancel it!'
    }).then((result) => {
        if (result.isConfirmed) {
            document.getElementById("addAddressForm").style.display = "none";
            document.getElementById("actualAddAddressForm").reset();
            clearErrors();
            Swal.fire(
                'Cancelled!',
                'Form has been reset.',
                'success'
            )
        }
    })
}

function showError(elementId, message) {
    const element = document.getElementById(elementId);
    const errorElement = document.getElementById(elementId + 'Error');
    element.classList.add('error');
    errorElement.style.display = 'block';
    errorElement.textContent = message;
}

function clearErrors() {
    const inputs = document.querySelectorAll('.form-control');
    inputs.forEach(input => {
        input.classList.remove('error');
        const errorElement = document.getElementById(input.id + 'Error');
        if (errorElement) {
            errorElement.style.display = 'none';
            errorElement.textContent = '';
        }
    });
}

function isEmptyOrWhitespace(str) {
    return !str || str.trim().length === 0;
}

document.getElementById("actualAddAddressForm").addEventListener("submit", async function(e) {
    e.preventDefault();
    clearErrors();
    let isValid = true;

    
    const name = document.getElementById("name").value;
    if (isEmptyOrWhitespace(name)) {
        showError("name", "Name cannot be empty");
        isValid = false;
    } else if (!/^[A-Za-z]+(?: [A-Za-z]+)*$/.test(name.trim())) {
        showError("name", "Name should contain only letters with single spaces between words");
        isValid = false;
    } else if (name.trim().length < 3 || name.trim().length > 50) {
        showError("name", "Name should be 3-50 characters long");
        isValid = false;
    }

    
    const phone = document.getElementById("phone").value;
    if (isEmptyOrWhitespace(phone)) {
        showError("phone", "Phone number cannot be empty");
        isValid = false;
    } else if (!/^[6-9]\d{9}$/.test(phone.trim())) {
        showError("phone", "Please enter a valid 10-digit phone number starting with 6-9");
        isValid = false;
    }

    
    const district = document.getElementById("district").value;
    if (isEmptyOrWhitespace(district)) {
        showError("district", "District cannot be empty");
        isValid = false;
    } else if (!/^[A-Za-z]+(?: [A-Za-z]+)*$/.test(district.trim())) {
        showError("district", "District should contain only letters with single spaces between words");
        isValid = false;
    } else if (district.trim().length < 3 || district.trim().length > 30) {
        showError("district", "District should be 3-30 characters long");
        isValid = false;
    }

   
    const city = document.getElementById("city").value;
    if (isEmptyOrWhitespace(city)) {
        showError("city", "City cannot be empty");
        isValid = false;
    } else if (!/^[A-Za-z]+(?: [A-Za-z]+)*$/.test(city.trim())) {
        showError("city", "City should contain only letters with single spaces between words");
        isValid = false;
    } else if (city.trim().length < 3 || city.trim().length > 30) {
        showError("city", "City should be 3-30 characters long");
        isValid = false;
    }

    
    const house = document.getElementById("house").value;
    if (isEmptyOrWhitespace(house)) {
        showError("house", "House/Building details cannot be empty");
        isValid = false;
    } else if (!/^[A-Za-z0-9\s,.-/#]{3,100}$/.test(house.trim())) {
        showError("house", "House/Building details should be 3-100 characters long and can contain letters, numbers, spaces, and common symbols (,.-/#)");
        isValid = false;
    }

    
    const state = document.getElementById("state").value;
    if (isEmptyOrWhitespace(state)) {
        showError("state", "State cannot be empty");
        isValid = false;
    } else if (!/^[A-Za-z]+(?: [A-Za-z]+)*$/.test(state.trim())) {
        showError("state", "State should contain only letters with single spaces between words");
        isValid = false;
    } else if (state.trim().length < 3 || state.trim().length > 30) {
        showError("state", "State should be 3-30 characters long");
        isValid = false;
    }

    
    const pincode = document.getElementById("pincode").value;
    if (isEmptyOrWhitespace(pincode)) {
        showError("pincode", "Pincode cannot be empty");
        isValid = false;
    } else if (!/^\d{6}$/.test(pincode.trim())) {
        showError("pincode", "Please enter a valid 6-digit pincode");
        isValid = false;
    }

    if (isValid) {
        try {
            const formData = new FormData(this);
            const response = await fetch('/addCheckAddress', {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json'
                },
                body: JSON.stringify(Object.fromEntries(formData))
            });

            const result = await response.json();

            if (result.success) {
                Swal.fire({
                    icon: 'success',
                    title: 'Success',
                    text: result.message,
                    showConfirmButton: false,
                    timer: 1500
                }).then(() => {
                    // Reload the current page
                    window.location.reload();
                });
            } else {
                Swal.fire({
                    icon: 'error',
                    title: 'Error',
                    text: result.message || 'Failed to add address'
                });
            }
        } catch (error) {
            console.error("Error adding address:", error);
            Swal.fire({
                icon: 'error',
                title: 'Error',
                text: 'Failed to add address. Please try again.'
            });
        }
    }
});


document.addEventListener('DOMContentLoaded', () => {
    // Load Razorpay checkout script
    const script = document.createElement('script');
    script.src = 'https://checkout.razorpay.com/v1/checkout.js';
    script.async = true;
    document.head.appendChild(script);

    const placeOrderButton = document.getElementById("placeOrderButton");
    
    const validateOrder = () => {
        const paymentMethod = document.querySelector('input[name="paymentMethod"]:checked')?.value;
        const selectedAddress = document.querySelector('.address-item.selected');
        const walletBalance = parseFloat(document.getElementById('walletBalance').textContent);
        const finalAmount = parseFloat('<%= finalAmount %>');

        if (!paymentMethod) {
            throw new Error('Please select a payment method.');
        }

        if (!selectedAddress) {
            throw new Error('Please select an address.');
        }

        if (paymentMethod === 'Wallet' && walletBalance < finalAmount) {
            throw new Error('Insufficient wallet balance.');
        }

        return {
            paymentMethod,
            addressId: selectedAddress.getAttribute('data-index')
        };
    };

    const handleRazorpayPayment = (orderData) => {
        const options = {
            key: orderData.razorpayOrder.key,
            amount: orderData.razorpayOrder.amount,
            currency: 'INR',
            name: 'Your Store Name',
            description: 'Order Payment',
            order_id: orderData.razorpayOrder.id,
            handler: async function(response) {
                try {
                    const verifyResponse = await fetch('/verify-razorpay-payment', {
                        method: 'POST',
                        headers: {
                            'Content-Type': 'application/json'
                        },
                        body: JSON.stringify({
                            razorpay_order_id: response.razorpay_order_id,
                            razorpay_payment_id: response.razorpay_payment_id,
                            razorpay_signature: response.razorpay_signature
                        })
                    });

                    if (!verifyResponse.ok) {
                        throw new Error('Payment verification failed');
                    }

                    const verifyResult = await verifyResponse.json();

                    if (verifyResult.success && verifyResult.orderId) {
                        await Swal.fire({
                            icon: 'success',
                            title: 'Payment Successful',
                            text: 'Order placed successfully!',
                            showConfirmButton: false,
                            timer: 2000
                        });
                        window.location.href = `/ordersuccess/${verifyResult.orderId}`;
                    } else {
                        throw new Error(verifyResult.message || 'Payment verification failed');
                    }
                } catch (error) {
                    console.error('Payment verification error:', error);
                    Swal.fire({
                        icon: 'error',
                        title: 'Payment Verification Failed',
                        text: error.message || 'An error occurred during payment verification'
                    });
                }
            },
            modal: {
                ondismiss: function() {
                    Swal.fire({
                        icon: 'warning',
                        title: 'Payment Cancelled',
                        text: 'You cancelled the payment process'
                    });
                }
            },
            prefill: {
                // Optional: Pre-fill customer details if available
                // name: customerName,
                // email: customerEmail,
                // contact: customerPhone
            },
            theme: {
                color: '#007bff'
            },
            retry: {
                enabled: true,
                max_count: 3
            }
        };

        const razorpay = new Razorpay(options);
        razorpay.on('payment.failed', function(response) {
            Swal.fire({
                icon: 'error',
                title: 'Payment Failed',
                text: response.error.description || 'Payment could not be processed'
            });
        });
        razorpay.open();
    };

    placeOrderButton.addEventListener("click", async () => {
        try {
            const { paymentMethod, addressId } = validateOrder();

            const response = await fetch("/place-order", {
                method: "POST",
                headers: {
                    "Content-Type": "application/json"
                },
                body: JSON.stringify({ paymentMethod, addressId })
            });

            if (!response.ok) {
                throw new Error('Failed to create order');
            }

            const result = await response.json();

            if (!result.success) {
                throw new Error(result.message || 'Failed to create order');
            }

            if (paymentMethod === 'Razorpay') {
                handleRazorpayPayment(result);
            } else if (paymentMethod === 'Wallet') {
                await Swal.fire({
                icon: 'success',
                title: 'Payment Successful!',
                text: 'Your order has been placed using wallet balance.',
                showConfirmButton: true,
                confirmButtonText: 'View Order',
                confirmButtonColor: '#28a745',
                timer: 3000,
                timerProgressBar: true
            });
                // Handle wallet payment success
                window.location.href = `/ordersuccess/${result.orderId}`;
            } else {
                // Handle COD
                window.location.href = `/ordersuccess/${result.orderId}`;
            }
        } catch (error) {
            console.error("Order placement error:", error);
            Swal.fire({
                icon: 'error',
                title: 'Order Placement Failed',
                text: error.message || 'An error occurred while placing the order'
            });
        }
    });

    // Payment method selection handling
    document.querySelectorAll('.payment-option').forEach(option => {
        option.addEventListener('click', function() {
            const radio = this.querySelector('input[type="radio"]');
            if (radio) {
                radio.checked = true;
                document.querySelectorAll('.payment-option').forEach(opt => {
                    opt.classList.remove('selected');
                });
                this.classList.add('selected');
            }
        });
    });
});
async function applyCoupon(couponCode) {
    try {
        const button = event.target;
        button.classList.add('loading');
        
        const response = await fetch('/apply-coupon', {
            method: 'POST',
            headers: {
                'Content-Type': 'application/json'
            },
            body: JSON.stringify({ couponCode })
        });
        
        const result = await response.json();
        
        if (result.success) {
            // Disable all other coupon cards
            document.querySelectorAll('.coupon-card').forEach(card => {
                card.classList.add('disabled');
                const btn = card.querySelector('.apply-coupon-btn');
                btn.disabled = true;
                btn.classList.add('disabled');
                btn.textContent = 'Coupon Unavailable';
            });

            Swal.fire({
                icon: 'success',
                title: 'Coupon Applied',
                text: result.message,
                showConfirmButton: false,
                timer: 1500
            }).then(() => {
                window.location.reload();
            });
        } else {
            Swal.fire({
                icon: 'error',
                title: 'Error',
                text: result.message
            });
        }
    } catch (error) {
        console.error('Error applying coupon:', error);
        Swal.fire({
            icon: 'error',
            title: 'Error',
            text: 'Failed to apply coupon'
        });
    } finally {
        button.classList.remove('loading');
    }
}

async function removeCoupon() {
    try {
        const response = await fetch('/remove-coupon', {
            method: 'POST',
            headers: {
                'Content-Type': 'application/json'
            }
        });
        
        const result = await response.json();
        
        if (result.success) {
            // Enable all coupon cards
            document.querySelectorAll('.coupon-card').forEach(card => {
                card.classList.remove('disabled');
                const btn = card.querySelector('.apply-coupon-btn');
                btn.disabled = false;
                btn.classList.remove('disabled');
                btn.textContent = 'Apply Coupon';
            });

            Swal.fire({
                icon: 'success',
                title: 'Coupon Removed',
                text: result.message,
                showConfirmButton: false,
                timer: 1500
            }).then(() => {
                window.location.reload();
            });
        } else {
            Swal.fire({
                icon: 'error',
                title: 'Error',
                text: result.message
            });
        }
    } catch (error) {
        console.error('Error removing coupon:', error);
        Swal.fire({
            icon: 'error',
            title: 'Error',
            text: 'Failed to remove coupon'
        });
    }
}

// Add this to your DOMContentLoaded event
document.addEventListener('DOMContentLoaded', function() {
    const appliedCoupon = document.querySelector('.applied-coupon');
    if (appliedCoupon) {
        // If there's an applied coupon, disable all coupon cards
        document.querySelectorAll('.coupon-card').forEach(card => {
            if (!card.classList.contains('disabled')) {
                card.classList.add('disabled');
                const btn = card.querySelector('.apply-coupon-btn');
                btn.disabled = true;
                btn.classList.add('disabled');
                btn.textContent = 'Coupon Unavailable';
            }
        });
    }
});

</script>

<%- include('../layoutsUser/userfooter') %>  

//viewOrder.ejs page :- 
<%- include('../layoutsUser/userheader') %>
<style>
    .order-history {
        font-family: Arial, sans-serif;
        margin: 0;
        padding: 20px;
        background-color: #f4f4f4;
    }
    .order-history .container {
        max-width: 800px;
        margin: auto;
        background: #fff;
        padding: 20px;
        border-radius: 8px;
        box-shadow: 0 0 10px rgba(0, 0, 0, 0.1);
    }
    .order-history h1 {
        text-align: center;
        color: #333;
    }
    .order-history table {
        width: 100%;
        border-collapse: collapse;
        margin-top: 20px;
    }
    .order-history th, .order-history td {
        padding: 12px;
        text-align: left;
        border-bottom: 1px solid #ddd;
    }
    .order-history th {
        background-color: #f8f8f8;
        font-weight: bold;
        color: #555;
    }
    .order-history .status {
        padding: 5px 10px;
        border-radius: 5px;
        color: #fff;
    }
    .order-history .paid {
        background-color: #28a745;
    }
    .order-history .pending {
        background-color: #ffc107;
    }
    .order-history .view-btn {
        background-color: #007bff;
        color: white;
        padding: 8px 12px;
        text-decoration: none;
        border-radius: 4px;
        font-size: 0.9em;
    }
    .order-history .view-btn:hover {
        background-color: #0056b3;
    }
    .pagination {
        display: flex;
        justify-content: center;
        align-items: center;
        gap: 5px;
        margin-top: 20px;
        font-size: 12px;
    }

   .pagination a, .pagination span {
        display: inline-block;
        padding: 5px 8px;
        text-decoration: none;
        color: #333;
        border: 1px solid #ddd;
        border-radius: 3px;
        transition: background-color 0.3s, color 0.3s;
    }

    .pagination a:hover {
        background-color: #007bff;
        color: white;
    }

   .pagination .active {
        background-color: #007bff;
        color: white;
        border: 1px solid #007bff;
    }
</style>

<div class="order-history">
    <div class="container">
        <h1>Your Order History</h1>
        <% if (orders && orders.length > 0) { %>
            <table>
                <thead>
                    <tr>
                        <th>Order Number</th>
                        <th>Date</th>
                        <th>Total</th>
                        <th>Payment Status</th>
                        <th>Order Status</th>
                        <th>Action</th>
                    </tr>
                </thead>
                <tbody>
                    <% paginatedOrders.forEach(order => { %>
                        <tr>
                            <td><%= order.orderId %></td>
                            <td><%= order.date %></td>
                            <td>₹<%= Math.round(order.totalPrice) %></td>
                            <td>
                                <span class="status <%= helpers.getStatusClass(order.paymentStatus) %>">
                                    <%= order.paymentStatus %>
                                </span>
                            </td>
                            <td><%= order.orderStatus %></td>
                            <td>
                                <a href="/orderDetails/<%= order.orderId %>" class="view-btn">View Details</a>
                            </td>
                        </tr>
                    <% }); %>
                </tbody>
            </table>
            
            <!-- Pagination -->
            <div class="pagination">
                <% if (currentPage > 1) { %>
                    <a href="?page=<%= currentPage - 1 %>">&laquo; Previous</a>
                <% } else { %>
                    <a class="disabled">&laquo; Previous</a>
                <% } %>
                
                <% for(let i = 1; i <= totalPages; i++) { %>
                    <a href="?page=<%= i %>" class="<%= currentPage === i ? 'active' : '' %>"><%= i %></a>
                <% } %>
                
                <% if (currentPage < totalPages) { %>
                    <a href="?page=<%= currentPage + 1 %>">Next &raquo;</a>
                <% } else { %>
                    <a class="disabled">Next &raquo;</a>
                <% } %>
            </div>
        <% } else { %>
            <div class="no-orders">
                <p>You haven't placed any orders yet.</p>
                <a href="/shop" class="view-btn">Continue Shopping</a>
            </div>
        <% } %>
    </div>
</div>
<%- include('../layoutsUser/userfooter') %>