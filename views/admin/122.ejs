shop controller 
const shop = async (req, res) => {
    try {
        const userData =await User.findById(req.session.user);
        
        let wishlistedProducts = [];
        if (userData) {
           const wishlist = await Wishlist.findOne({ userId: userData._id });
         if (wishlist) {
            wishlistedProducts = wishlist.items.map(item => item.productId.toString());
         }
        }

        const selectedCategory = req.query.Category;
        const searchQuery = req.query.q ? req.query.q.trim() : '';

    const listedCategories = await Category.aggregate([
        { $match: { isListed: true } },
        {
            $lookup: {
                from: "products", 
                let: { categoryId: "$_id" },
                pipeline: [
                    { $match: { $expr: { $eq: ["$category", "$$categoryId"] }, isBlocked: false } } 
                ],
                as: "products"
            }
        },
        {
            $addFields: {
                count: { $size: "$products" } 
            }
        },
        {
            $project: { _id: 1, name: 1, count: 1 } 
        }
    ]);

      const categoryIds = listedCategories.map(category => category._id);
  
      let filter = { isBlocked: false };

      if (selectedCategory) {
        const category = await Category.findOne({ name: selectedCategory, isListed: true });
        if (category) {
          filter.category = category._id; 
        }
      } else {
        filter.category = { $in: categoryIds }; 
      }

      if (searchQuery) {
        const searchTerms = searchQuery.trim().split(/\s+/);
        
        filter.$or = [
            { 
                productName: { 
                    $regex: new RegExp(searchTerms.map(term => `\\b${term}`).join('|'), 'i') 
                }
            }
        ];
      }
  
      const page = parseInt(req.query.page) || 1; 
      const limit = 9; 
      const skip = (page - 1) * limit; 
      const totalProducts = await Product.countDocuments(filter);
      const totalPages = Math.ceil(totalProducts / limit);

      let sortOption = {};
        let priceSort = req.query['price-sort']; 
        const nameSort = req.query['name-sort'];


        if (priceSort === 'lowToHigh') {
            sortOption.regularPrice = 1;
        } else if (priceSort === 'highToLow') {
            sortOption.regularPrice = -1;
        }

        const sortStage = [
            { $match: filter },
            {
                $lookup: {
                    from: "offers",
                    localField: "_id",
                    foreignField: "productId",
                    pipeline: [
                        {
                            $match: {status: "Active",expireDate: { $gt: new Date() } }
                        }
                    ],
                    as: "productOffers"
                }
            },
            {
                $lookup: {
                    from: "offers",
                    localField: "category",
                    foreignField: "categoryId",
                    pipeline: [
                        {
                            $match: { status: "Active",expireDate: { $gt: new Date() } }
                        }
                    ],
                    as: "categoryOffers"
                }
            },
            {
                $addFields: {
                    highestOffer: {
                        $let: {
                            vars: {
                                allOffers: { $concatArrays: ["$productOffers", "$categoryOffers"] }
                            },
                            in: {$ifNull: [{ $max: "$$allOffers.discount"},0]}
                        }
                    },
                    offerPrice: {
                        $let: {
                            vars: { maxDiscount: {$ifNull: [{$max: {$map: {input: { $concatArrays: ["$productOffers", "$categoryOffers"] },as: "offer",in: "$$offer.discount"}}},0]}},
                            in: {$subtract: ["$regularPrice",{$multiply: ["$regularPrice",{ $divide: ["$$maxDiscount", 100] }]}]}}}
                        }
                    }
        ];
  
        if (nameSort === 'aToZ') {
            sortStage.push({ $addFields: { lowerName: { $toLower: "$productName" } } });
            sortStage.push({ $sort: { lowerName: 1 } });
        } else if (nameSort === 'zToA') {
            sortStage.push({ $addFields: { lowerName: { $toLower: "$productName" } } });
            sortStage.push({ $sort: { lowerName: -1 } });
        } else if (Object.keys(sortOption).length > 0) {
            sortStage.push({ $sort: sortOption });
        }

        sortStage.push({ $skip: skip });
        sortStage.push({ $limit: limit });
     
       const products = await Product.aggregate(sortStage);

       const productsWithWishlistStatus = products.map(product => ({
        ...product,
        isWishlisted: wishlistedProducts.includes(product._id.toString())
      }));

      res.render("shop", {
          products: productsWithWishlistStatus,
          userData,
          category: listedCategories,
          selectedCategory,
          currentPage: page,
          totalPages,
          priceSort,
          nameSort,
          searchQuery
      });
  } catch (error) {
      console.error("Error in shop", error);
      res.status(500).json({ success: false, message: "An error occurred" });
  }
};
